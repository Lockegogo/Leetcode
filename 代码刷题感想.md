# 代码刷题感想

==2022.4.15==

1. 只出现一次的数字：使用==位运算==，异或运算可解
2. 多数元素：使用==摩尔投票法==，什么是摩尔投票法，思考一下，开心消消乐，数字相同投票数加1，否则投票数减1，投票数为0后设 x 为新值，**是兄弟就来砍我**。
3. 搜索二维矩阵 II：矩阵横向递增，纵向递增，是一道剑指 offer 的原题
   1. 我的做法是先定义一个二分查找函数，然后横向搜索，再纵向搜索
   2. 更高效的解法是从矩阵右上角开始比较，如果目标值更大，则向下搜索，如果目标值更小，则向左搜索
   3. **思考下为什么是从右上角开始比较**

==2022.4.17==

1. 合并两个有序数组：思路想对了，三指针法，两个指针 m 和 n，从后往前遍历 nums1 和 nums2 ，第三个指针代表放的位置，将大的数字放到 nums1 的最后面，依次向前放，但是边界条件控制不清楚，如果是因为 j < 0 退出循环，说明第二个列表中的值已经全部添加进入第一个列表，任务完成，但是如果是因为 i < 0 退出循环，说明此时 nums1 中的数全部放在了 nums1 的后面，但是 nums2 的值可能还没有添加完，所以在最后加上这一行代码：`nums1[0: j + 1] = nums2[0: j + 1]`，注意列表的赋值要使用 `numsA[:] = numsB[:]`

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # 两个指针，从后往前比较
        i = m-1
        j = n-1
        k = len(nums1) - 1
        while j >= 0 and i >= 0:
            if nums1[i] <= nums2[j]:
                nums1[k] = nums2[j]
                j -= 1
            elif nums1[i] > nums2[j]:
                nums1[k] = nums1[i]
                i -= 1
            k -= 1
        nums1[0: j + 1] = nums2[0: j + 1]
        
```

2. ==鸡蛋掉落问题==：没有任何思路，看了答案，难度很大：动态规划 + 二分查找
   1. https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/
3. 验证回文字符串：我用了常规的双指针比较法，下面是很高级的解法

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = s.lower()
        # [] 对单个字符给出取值范围，re.findall 返回的是一个列表
        s1 = re.findall(r'[a-z0-9]', s)
        s2 = "".join(s1)
        # 使用字符串切片反转
        return s2[::-1] == s2
```

4. 分割回文串：一开始只能想到回溯法，还是比较难的回溯题，没有办法一下子写出来，回顾了之前的笔记
5. 单词拆分：多重背包问题，注意背包要正序遍历，一般情况是先物品再背包，但这一题比较特殊，先背包再物品
6. 单词拆分 II：和上一题不同，要返回所有符合题意的组合，无法使用动态规划，尝试写回溯

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        path = []
        res = []
        def valid(word):
            if word in wordDict:
                return True
            else:
                return False
        def backtrack(s, startindex):
            # 当指针走到最后就停止
            if startindex == len(s):
                res.append(' '.join(path))
                return

            for i in range(startindex, len(s)):
                if not valid(s[startindex:i+1]):
                    continue
                path.append(s[startindex:i+1])
                backtrack(s, i + 1)
                path.pop()
        backtrack(s, 0)
        return res
```

7. 实现前缀树：前缀树（字典树）是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。前缀树可以用 $O(|S|)$ 的时间复杂度完成如下操作，其中 $|S|$ 是插入字符串或查询前缀的长度：
8. 单词搜索 II：给定一个 `m x n` 二维字符网格 `board` 和一个单词（字符串）列表 `words`， *返回所有二维网格上的单词* 。
   1. 完全没有思路，想用深度优先搜索，但是代码写不出来
   2. 

​	

9. 有效的字母异位词：字典加减

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        from collections import Counter
        return Counter(s)==Counter(t)
```

10. 字符串中的第一个唯一字符：字典
11. 反转字符串：`s[i], s[j] = s[j], s[i]`
12. 乘积最大子数组：注意不要到连续和最大子数组的误区！[-2,3,-4] 这种情况乘积最大是 24，普通的 dp 回答错误，因为当前位置的最优解未必是由前一个位置的最优解转移得到的，我们可以根据正负性进行分类讨论：
    - 如果当前位置是负数，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。
    - 如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。
    - 所以维护两个 dp 数组

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        # 维护两个 dp 数组
        dp_max = [0]*len(nums)
        dp_max[0] = nums[0]
        dp_min = [0]*len(nums)
        dp_min[0] = nums[0]
        for i in range(1, len(nums)):
            dp_max[i] = max(nums[i], dp_max[i-1]*nums[i], dp_min[i-1]*nums[i])
            dp_min[i] = min(nums[i], dp_max[i-1]*nums[i], dp_min[i-1]*nums[i])
        return max(dp_max)
```

==2022.4.22==

13. 多数元素：摩尔投票法，无需多言
14. 旋转数组：三次翻转，注意在写反转函数的时候，传入参数是 $i$ 和 $j$，不要传入数组，不要写 `reverse(nums[:k])`，而应该写 `reverse(0,k-1)` 这种
15. 存在重复元素：一个字典解决，如果元素在字典中存在，返回 True
16. 移动零：双指针，但是边界问题没有处理好。
    - 左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
    - 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        n = len(nums)
        left = right = 0
        while right < n:
            if nums[right] != 0:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1
```

17. 打乱数组：没啥思路，看看题解

==2022.5.13==

18. 两个数组的交集 II：

 -  排序

 -  双指针遍历两个数组，如果数组 1 小，1 的下标右移，2 小 2 右移

 -  如果相等，加入目标数组，双双右移

    



